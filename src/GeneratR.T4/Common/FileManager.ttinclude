<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Linq" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating"#><#+

/// <summary>
///		FileManager class records the various blocks so it can split them up into different files.
/// </summary>
/// <remarks>
///		Originally created by DamienG: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
///		Revised by Morten Korsgaard (korsg.dk) to handle multiple output files in different projects/folders.
/// </remarks>
public class FileManager 
{
    protected class Block 
	{
        public string Name;
		public string ProjectName;
		public string FolderName;
        public int Start, Length;
        public bool IncludeInDefault;
		public Dictionary<string, string> FileProperties;
    }

	protected class GeneratedFile
    {
		public string FileName;
		public string ProjectName;
		public string FolderName;
		public Dictionary<string, string> FileProperties;
    }

    private Block currentBlock;
    private readonly List<Block> files = new List<Block>();
    protected readonly List<GeneratedFile> generatedFiles = new List<GeneratedFile>();
    private readonly Block footer = new Block();
    private readonly Block header = new Block();
    protected readonly ITextTemplatingEngineHost host;
    protected readonly StringBuilder template;
    /// <summary>The templates full directory path.</summary>
	protected readonly string templateDirectoryName;
    /// <summary>The templates file name without extension.</summary>
	protected readonly string templateFileNameWithoutExtension;

    public static FileManager Create(ITextTemplatingEngineHost host, StringBuilder template) 
	{
        return (host is IServiceProvider) ? new VSFileManager(host, template) : new FileManager(host, template);
    }

    private FileManager(ITextTemplatingEngineHost host, StringBuilder template) 
	{
        this.host = host;
        this.template = template;
		this.templateDirectoryName = Path.GetDirectoryName(host.TemplateFile);
		this.templateFileNameWithoutExtension = Path.GetFileNameWithoutExtension(host.TemplateFile);
    }

    public void StartNewFile(string name, string projectName = "", string folderName = "", Dictionary<string, string> fileProperties = null) 
	{
        if (name == null) { throw new ArgumentNullException("name"); }
        CurrentBlock = new Block { 
			Name = name, 
			ProjectName = projectName, 
			FolderName = folderName, 
			FileProperties = fileProperties ?? new Dictionary<string, string>() 
		};
    }

    public void StartFooter(bool includeInDefault = true) 
	{
        CurrentBlock = footer;
        footer.IncludeInDefault = includeInDefault;
    }

    public void StartHeader(bool includeInDefault = true) 
	{
        CurrentBlock = header;
        header.IncludeInDefault = includeInDefault;
    }

    public void EndBlock() 
	{
        if (CurrentBlock == null) { return; }
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
        {  
			files.Add(CurrentBlock);
        }
        currentBlock = null;
    }

    public virtual void Process(bool split, bool sync = true) 
	{
        if (split) 
		{
            EndBlock();
            var headerText = template.ToString(header.Start, header.Length);
            var footerText = template.ToString(footer.Start, footer.Length);
            var templateDirectoryPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();

            if (!footer.IncludeInDefault) 
			{
                template.Remove(footer.Start, footer.Length);
            }
           
			var groupedFiles = 
				(from f in files
				group f by new { f.ProjectName, f.FolderName }
				into l
				select new {
					ProjectFileName = l.Key.ProjectName,
					FolderName = l.Key.FolderName,
					Files = l
				});

            foreach (var fg in groupedFiles)
            {
				var projectFileName = fg.ProjectFileName;
				var folderName = fg.FolderName;

				string outputPath;
				if (!string.IsNullOrWhiteSpace(projectFileName))
                {
					var projectFile = new FileInfo(Path.Combine(templateDirectoryPath, projectFileName));
					if (!projectFile.Exists) { throw new Exception("Project file not found: " + projectFile.FullName); }
					outputPath = Path.Combine(projectFile.DirectoryName, fg.FolderName);
                }
				else if(!string.IsNullOrWhiteSpace(folderName))
                {
					outputPath = Path.Combine(templateDirectoryPath, fg.FolderName);
                }
				else 
				{
					outputPath = templateDirectoryPath;
                }
					
				var outputDirectory = new DirectoryInfo(outputPath);
				if (!outputDirectory.Exists)
                {
					outputDirectory.Create();
                }

				foreach(Block block in fg.Files) 
				{
					var fileName = Path.Combine(outputDirectory.FullName, block.Name);
					var content = headerText + template.ToString(block.Start, block.Length) + footerText;
					generatedFiles.Add(new GeneratedFile() { FileName = fileName, ProjectName = block.ProjectName, FolderName = block.FolderName, FileProperties = block.FileProperties });
					CreateFile(fileName, content);
					template.Remove(block.Start, block.Length);
				}
            }
            
			if (!header.IncludeInDefault)
			{
                template.Remove(header.Start, header.Length);
            }
        }
    }

    protected virtual void CreateFile(string fileName, string content) 
	{
        if (IsFileContentDifferent(fileName, content))
        {
            File.WriteAllText(fileName, content);
        }
    }

    public virtual string GetCustomToolNamespace(string fileName) 
	{
        return null;
    }

    public virtual string DefaultProjectNamespace 
	{
        get { return null; }
    }

    protected bool IsFileContentDifferent(string fileName, string newContent) 
	{
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Block CurrentBlock 
	{
        get { return currentBlock; }
        set 
		{
            if (CurrentBlock != null)
            {   
				EndBlock();
            }
            if (value != null)
            {
                value.Start = template.Length;
            }
            currentBlock = value;
        }
    }

    private class VSFileManager : FileManager 
	{
        private readonly EnvDTE.ProjectItem templateProjectItem;
        private readonly EnvDTE.DTE dte;
		private readonly VisualStudioHelper vsHelper;
        private readonly Action<string> checkOutAction;
        private readonly Action<List<GeneratedFile>> projectSyncAction;
		
        internal VSFileManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) 
		{
            var hostServiceProvider = (IServiceProvider)host;
            if (hostServiceProvider == null) 
			{
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            }
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
			{
                throw new ArgumentNullException("Could not obtain DTE from host");
            }
			vsHelper = new VisualStudioHelper(host);
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = fileName => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = keepFiles => ProjectSync(templateProjectItem, keepFiles);
        }

        public override string DefaultProjectNamespace { get { return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString(); } }

        public override string GetCustomToolNamespace(string fileName) { return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString(); }

        public override void Process(bool split, bool sync = true) 
		{
            if (templateProjectItem.ProjectItems == null) { return; }
            base.Process(split, sync);
            if (sync)
            {
                //projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFiles, null, null));
				projectSyncAction(generatedFiles);
            }
        }

        protected override void CreateFile(string fileName, string content) 
		{
            if (IsFileContentDifferent(fileName, content)) 
			{
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        private void ProjectSync(EnvDTE.ProjectItem templateProjectItem, List<GeneratedFile> generatedFiles) 
		{
			IEnumerable<string> generatedFileNames = generatedFiles.Select(x => x.FileName);

			var groupedFiles = 
				(from f in generatedFiles
				group f by new { f.ProjectName, f.FolderName }
				into l
				select new {
					ProjectFileName = l.Key.ProjectName,
					FolderName = l.Key.FolderName,
					Files = l
				});

			// Add generated files to solution.
			foreach (var fg in groupedFiles)
            {
				var projectFileName = fg.ProjectFileName;
				var folderName = fg.FolderName;

				EnvDTE.ProjectItems projectItems;
				if (!string.IsNullOrWhiteSpace(projectFileName))
                {
					var projectFile = new FileInfo(Path.Combine(templateDirectoryName, projectFileName));
					if (!projectFile.Exists) { throw new Exception("Project file not found: " + projectFile.FullName); }
					var proj = vsHelper.GetProjectByFileName(projectFile.FullName);
					projectItems = proj.ProjectItems;
                }
				else if(!string.IsNullOrWhiteSpace(folderName))
                {
					projectItems = templateProjectItem.ContainingProject.ProjectItems;
                }
				else 
				{
					projectItems = templateProjectItem.ProjectItems;
                }
					
				foreach(GeneratedFile file in fg.Files) 
				{
					var projectItem = vsHelper.FindProjectItem(file.FileName);
					if (projectItem == null)
					{
						projectItem = projectItems.AddFromFile(file.FileName);
					}
					// Set properties.
                    foreach (KeyValuePair<string,string> kv in file.FileProperties)
                    {
						vsHelper.SetPropertyValue(projectItem, kv.Key, kv.Value);
                    }
				}
            }

			// Load previously generated filenames from log, and delete any excess.
			var generatedFileLogStartName = "--GENERATED FILE LOG START--";
			var generatedFileLogEndName = "--GENERATED FILE LOG END--";
			var logFileSuffix = ".generated.log";
			var logFileName = Path.Combine(templateDirectoryName, templateFileNameWithoutExtension + logFileSuffix);
			var previousLogProjectItem = templateProjectItem.ProjectItems.Cast<EnvDTE.ProjectItem>().Where(x => x.Name.EndsWith(logFileSuffix)).FirstOrDefault();
			if (previousLogProjectItem != null)
            {
				var previousLogFileName = previousLogProjectItem.FileNames[0];
				var previousContent = string.Empty;
				if (File.Exists(previousLogFileName))
                {
					previousContent = File.ReadAllText(previousLogFileName);
				}
				var startIndex = previousContent.IndexOf(generatedFileLogStartName);
				var endIndex = previousContent.IndexOf(generatedFileLogEndName);
				if (startIndex > -1 && endIndex > -1)
				{
					startIndex += generatedFileLogStartName.Length;
					var logContent = previousContent.Substring(startIndex, endIndex - startIndex - 1); 
					var fileNames = logContent.Split(new string[] {Environment.NewLine}, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim());
					var excessFiles = fileNames.Except(generatedFileNames);
					foreach (var fileName in excessFiles)
					{
						var projectItem = vsHelper.FindProjectItem(fileName);
						if (projectItem != null)
						{
							projectItem.Delete();
						}
					}
				}
				// Delete previous log file item if name of template has changed.
				if (!previousLogFileName.Equals(logFileName, StringComparison.OrdinalIgnoreCase))
                {
					previousLogProjectItem.Delete();
                }
            }

			// Write generated filenames log
			var logBuilder = new StringBuilder();
			logBuilder.AppendLine(generatedFileLogStartName);
			foreach (var fileName in generatedFileNames)
            {
				logBuilder.AppendLine(fileName);
            }
			logBuilder.AppendLine(generatedFileLogEndName);

			File.WriteAllText(logFileName, logBuilder.ToString());
			CheckoutFileIfRequired(logFileName);

			if (vsHelper.FindProjectItem(logFileName) == null)
			{
				var logFileProjectItem = templateProjectItem.ProjectItems.AddFromFile(logFileName);
				if (vsHelper.ContainsProperty(logFileProjectItem, "DependentUpon"))
				{
					vsHelper.SetPropertyValue(logFileProjectItem, "DependentUpon", templateProjectItem.Name);
				}
            }
        }

        private void CheckoutFileIfRequired(string fileName) 
		{
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
            {    
				checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
            }
        }
    }

	/// <summary>
	/// Provides functionality for automating Visual Studio.
	/// </summary>
	public class VisualStudioHelper 
	{
		/// <summary>
		/// Creates a new instance of this class
		/// </summary>
		public VisualStudioHelper(object host)
		{
			// Store a reference to the template host we will need this frequently
			this.Host = host as ITextTemplatingEngineHost;
		}
	
		private EnvDTE.DTE _DTE = null;
		/// <summary>
		/// Returns a reference to the primary management object of Visual Studio
		/// <summary>
		public EnvDTE.DTE DTE
		{
			get
			{
				if (_DTE == null)
				{
					var hostServiceProvider = this.Host as IServiceProvider;
					if (hostServiceProvider != null)
						_DTE = hostServiceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
				}
				return _DTE;
			}
		}
	
		/// <summary>
		/// Stores a reference to the Host of the t4 template
		/// </summary>
		public ITextTemplatingEngineHost Host { get; private set; }

		#region Solution and Projects

		/// <summary>
		/// Gets the full path of the solution file
		/// </summary>
		public string SolutionFile
		{
			get
			{
				return this.DTE.Solution.FileName;
			}
		}
		/// <summary>
		/// Gets the file name of the currently opened solution.
		/// </summary>
		public string SolutionFileName
		{
			get
			{
				return System.IO.Path.GetFileName(this.DTE.Solution.FileName);
			}
		}
		/// <summary>
		/// Gets the name of the currently opened solution
		/// </summary>
		public string SolutionName
		{
			get
			{
				return this.DTE.Solution.Properties.Item("Name").Value.ToString();
			}
		}

		/// <summary>
		/// Gets a list of all Projects within the solution
		/// </summary>
		public IEnumerable<EnvDTE.Project> GetAllProjects()
		{
			var ret = new List<EnvDTE.Project>();

			// Take all projects that are at top level of the solution and recursively search Project folders
			var topLevelProjects = this.DTE.Solution.Projects;

			foreach(EnvDTE.Project project in topLevelProjects)
			{
				if (project.Kind == vsProjectType.SolutionFolder)
					ret.AddRange(GetProjectsFromItemsCollection(project.ProjectItems));
				else
					ret.Add(project);
			}

			return ret;
		}

		/// <summary>
		/// Gets the project object within the current solution by a given project name.
		/// </summary>
		public EnvDTE.Project GetProjectByName(string projectName)
		{
			return this.GetAllProjects()
					   .Where(p => p.Name == projectName)
					   .First();
		}

		/// <summary>
		/// Gets the project object within the current solution by a given project filename.
		/// </summary>
		public EnvDTE.Project GetProjectByFileName(string projectFileName)
		{
			return this.GetAllProjects()
					   .Where(p => p.FileName == projectFileName)
					   .First();
		}

		/// <summary>
		/// Gets the project containing the .tt-File
		/// </summary>
		public EnvDTE.Project CurrentProject
		{
			get
			{
				return this.FindProjectItem(this.Host.TemplateFile).ContainingProject;
			}
		}

		#endregion

		#region Project Items

		public EnvDTE.ProjectItem FindProjectItem(string fileName)
		{
			return this.DTE.Solution.FindProjectItem(fileName);
		}

		/// <summary>
		/// Gets all project items from the current solution
		/// </summary>
		public IEnumerable<EnvDTE.ProjectItem> GetAllSolutionItems()
		{
			var ret = new List<EnvDTE.ProjectItem>();

			// Iterate all projects and add their items
			foreach(EnvDTE.Project project in this.GetAllProjects())
				ret.AddRange(GetAllProjectItems(project));

			return ret;
		}

		/// <summary>
		/// Gets all project items from the current project
		/// </summary>
		public IEnumerable<EnvDTE.ProjectItem> GetAllProjectItems()
		{
			// Get the project of the template file and reeturn all its items
			var project = this.CurrentProject;
			return GetAllProjectItems(project);
		}

		/// <summary>
		/// Gets all Project items from a given project. 
		/// </summary>
		public IEnumerable<EnvDTE.ProjectItem> GetAllProjectItems(EnvDTE.Project project)
		{
			return this.GetProjectItemsRecursively(project.ProjectItems);
		}
		
		/// <summary>
		/// Sets a property value for the vs project item.
		/// </summary>
		public void SetPropertyValue(EnvDTE.ProjectItem item, string propertyName, object value)
		{
			EnvDTE.Property property = item.Properties.Item(propertyName);
			if (property == null)
			{
				throw new ArgumentException(String.Format("The property {0} was not found.", propertyName));
			}
			else if (!property.Value.Equals(value))
			{
				property.Value = value;
			}
		}

		/// <summary>
		/// Get if property for the vs project item exists.
		/// </summary>
		public bool ContainsProperty(EnvDTE.ProjectItem item, string propertyName)
        {
			return item.Properties.Item(propertyName) != null;
        }

		#endregion

		private List<EnvDTE.Project> GetProjectsFromItemsCollection(EnvDTE.ProjectItems items)
		{
			var ret = new List<EnvDTE.Project>();

			foreach(EnvDTE.ProjectItem item in items)
			{
				if (item.SubProject == null)
					continue;
				else if (item.SubProject.Kind == vsProjectType.SolutionFolder)
					ret.AddRange(GetProjectsFromItemsCollection(item.SubProject.ProjectItems));
				else if (item.SubProject.Kind == vsProjectType.VisualBasic
					  || item.SubProject.Kind == vsProjectType.VisualCPlusPlus
					  || item.SubProject.Kind == vsProjectType.VisualCSharp
					  || item.SubProject.Kind == vsProjectType.VisualJSharp
					  || item.SubProject.Kind == vsProjectType.WebProject
					  || item.SubProject.Kind == vsProjectType.DotNetCore
					  || item.SubProject.Kind == vsProjectType.UniversalApp
					  || item.SubProject.Kind == vsProjectType.SharedProject
					  || item.SubProject.Kind == vsProjectType.SSDT)
					ret.Add(item.SubProject);
			}

			return ret;
		}

		private List<EnvDTE.ProjectItem> GetProjectItemsRecursively(EnvDTE.ProjectItems items)
		{
			var ret = new List<EnvDTE.ProjectItem>();
			if (items == null) return ret;
		
			foreach(EnvDTE.ProjectItem item in items)
			{
				ret.Add(item);
				ret.AddRange(GetProjectItemsRecursively(item.ProjectItems));
			}

			return ret;
		}

		private class vsProjectType
		{
			public const string SolutionFolder = "{66A26720-8FB5-11D2-AA7E-00C04F688DDE}";
			public const string VisualBasic = "{F184B08F-C81C-45F6-A57F-5ABD9991F28F}";
			public const string VisualCSharp = "{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}";
			public const string VisualCPlusPlus = "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}";
			public const string VisualJSharp = "{E6FDF86B-F3D1-11D4-8576-0002A516ECE8}";
			public const string WebProject = "{E24C65DC-7377-472b-9ABA-BC803B73C61A}";
			public const string DotNetCore = "{9A19103F-16F7-4668-BE54-9A1E7A4F7556}";
			public const string UniversalApp = "{262852C6-CD72-467D-83FE-5EEB1973A190}";
			public const string SharedProject = "{D954291E-2A0B-460D-934E-DC6B0785DB48}";
			public const string SSDT = "{00d1a9c2-b5f0-4af3-8072-f6c62b433612}";
		}	
	}

} #>